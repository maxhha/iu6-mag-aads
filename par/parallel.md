# 2023-09-23 парвыч
## SSE
- XMM регистры

Disp - смещение (0, 8 и 32 бита)
Base - база (любой 32 POH)
Index - индекс (любой 32 POH, кроме ESP)
Scale - масштаб (1,2,4 и 8)

EA = Base + Index * Scale + Disp

movsx - заполнить знаком при дополнении
movzx - заполнить 0 при дополнении

div
idiv - целочисленное деление
mul
imul

SSE - не рассматриваем команды преобразования и сравнения данных

movaps - кратен 16 байтам
movups
movss
movhlps
...

DDR5 - 128 байт
DDR3 - 64 байта


DDR4 - 128 гигабайт
32 гигабайт - 2^35 (29 бит адреса)

8 асоциативный кэш
кэш делится на 8 блоков, 1 блок 512 байт
первые 64 байта - каждая ячейка памяти может встать в 8 ячеек.

shufps

## Почему 16 байт? Почему адрес должен быть выравнен

64битный процесс - он поддерживает 32битный процесс

16 байт регистры

2000год
DDR 200мГц

процессор был быстрее памяти.

почему нельзя сделать 1гигаГц скорость памяти - из-за наводок. Проводники работают как антены.

DDR имела задержки такие же
Время ожидания ответа одинаковое на DDR и SDRAM
DDR - выгоднее получить блок данных
за 1 такт можно передать 2 порции данных (16 байт в сумме для 64 битной шины)

П <=> КЭШ <=> ОЗУ
Процессор сначала смотрит в КЭШЕ данные, потом КЭШ проверят в ОЗУ
КЭШ - ассоциативная память (ключ - адрес, значение - часть памяти)
DDR3 - максимум 32гб оперативной памяти

в полтора раза быстрее (читаем блоки по 16 байт) - с вер-тью 1/2 можем пересечь границу.
При чтении - есть упреждающее чтение.

DDR3 - 1600 МГц - (6-6-6-18 - лучшие задержки) - по спаду и фронту
DDR4 - улучшенная DDR4
DDR5 - может работать как DDR4

из-за размера кэш линейки передаем 16 байт.
пересечение границы в 64 байтах значительно меньше - но

случайное чтение - 2гигабайта в секунду

блочное (1мб последовательно читаем) - 10гигабайт в секунду
запись - 6гигабайт в секунду

```
DDR 100Мгц
DDR3
200МГц
6-6-6-18
^ ^ ^ ^
| | | + минимальный промежуток когда вы начнете закрывать строку
| | + сколько нужно, чтобы закрыть строку
| + сколько тактов нужно, чтобы открыть
+ конденсантор должен держать заряд 2мс - 1000 раз в секунду идет перезапись всей памяти
  1 гигабайт (2^30) - обновляется одна линейка памяти из 2^15 ячеек. 2^15 нужно обновить
  в секунду (33MГц)
  DDR - до 8 откыртых строк параллельно
```

семафор
init(n)
enter()
leave()

взаимные блокировки

критическая секция работает с потоками только 1 процесса - это 1 отличие от mutex
2 отличие mutex и крит секции - можно рекурсивно входить в эту секцию (несколько раз)
futex - быстрая реализация mutex в user mode

getStdHandle

setConsoleCursorPosition

hConsole = getStdHandle(STD_OUTPUT_HANDLE);
cor.x = 10;
cor.y = 10
setConsoleCursorPosition(hConsole, cor);
printf("");

## 2023-11-18


8 элементов (double ов) в кэше

упреждающее чтение: если прочитали 1 кэш линейку, получаем следующую кэш ленейку, даже если не было запроса.

читаем матрицу,
8 раз медленнее


### MPI

OpenMP - параллельность с общей памятью, а MPI - у каждого исполнителя своя память

rc = MPI_xxxx(paramers,...) == MPI_SUCCESS

mpirun -np N <программа с аргументами>

группа процессов:
ранг есть у каждого процесса, 1 процесс может быть в нескольких группах
коммуникатор - передает сообщения.
коммуникатор A: 1 2
коммуникатор Б: 3 4

атрибуты процесса: коммуникатор, номер ранга в коммуникаторе
Сообщение:

```
#include <mpi.h>

int main(int argc, char **argv) {
  int rc = MPI_Init(&argc, &argv);
  rc = MPI_Finalize();
}
```

типы сообщений:
1-1
1 процесс отправляет всем
все отправляют 1-му
mpi ubuntu

когда вышли из функции MPI_Send, можно использовать в buf.
Не означает, что письмо получено.

```

MPI_Bsend - передача с буферизацией. (Если прием сообщения не был инициализирован получателем, то сообщение запишется в буфер)

int MPI_Buffer_attach
int MPI_Buffer_detach

буфер только 1. Нужно выделить + MPI_BSEND_OVERHEAD

MPI_Ssend

```

```
MPI_Irsend - асинхронная (для общности)

MPI_probe - выходим только когда есть сообщение, MPI_Iprobe - по флагу можно понять, есть ли сообщение.

MPI_Waitall
MPI_Waitany
MPI_Waitsome

Аналогично с MPI_Testany
MPI_Start

```

```
группа = коммуникатор + среду обмена сообщений

работа с групповая с коммуникатором - коллективная операция, должна быть вызвана на всех процессах коммуникатора.

операции на группы локальные

процессов много, а код 1

MPI_Comm_split

виртуальная топология - механизм сопоставления процессам некоторого коммуникатора альтернативной схемы адресации

нужно изменить ранги у коммуникатора.

коммуникатор - столбец/строка

декартова - один коммуникатор, квадратная. Если меньше - ошибка, больше - лишние не будут включены

MPI_Topo_test - проверка наличия топологии

альтернативная схема адресации, для удобства алгоритма


```

к экзамену нужны определения, чет объяснить про sse, насколько можно максимально ускорить программу.

Посчитать функцию для ряда маклорена. мин кол-во реоргинизаций

Обосновать эффективность - во сколько раз может быть распараллелено.
С sse - эффективно использует память и регистры
пропускная способность ограничена - потоки будут мешать друг другу.

суммирования в процессоре, а данные из кучи мест,  поэтому эффективнее работать с меньшим числом потоков.

Узкое место - или память, или проц.
Функция, рассчитывает по нескольким x, для них y-ки.

mpi - на каждый процесс свой диапазон.


